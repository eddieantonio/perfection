#!/usr/bin/env python
# coding: utf-8

"""
Utilities for generating perfect hash functions for integer keys.

This module implements the first fit decreasing method, described in
Gettys01_. It is **not** guarenteed to generate a *minimal* perfect hash,
though by no means is it impossible. See for example:

>>> phash = hash_parameters('+-<>[].,', to_int=ord)
HashInfo(t=8, r=(0, 1, 4, 5, 0, 0, 0, 0), offset=-43, to_int=ord)

    
.. _Gettys01: http://www.drdobbs.com/architecture-and-design/generating-perfect-hash-functions/184404506

"""


import math
import collections
import heapq

# TODO: MAKE THIS UNNECESSARY.
from operator import itemgetter
# TODO: GET RID OF pprint!
from pprint import pprint

HashInfo = collections.namedtuple('HashInfo', 't slots r offset to_int')

def hash_parameters(keys, minimize=True, to_int=None):
    """
    Calculates the parameters for a perfect hash. The result is returned as a
    HashInfo tuple which has the following fields:

        t       -- table parameters 
        slots   -- the output slots in the domain
        r       -- displacement vector
        offset  -- the amount by which to offset all values (once converted to
                   ints)
        to_int  -- function to convert input to int (if given)

    >>> hash_parameters([1, 5, 7], minimize=False)
    HashInfo(t=3, slots=(1, 5, 7), r=(None, 0, 1), offset=0, to_int=None)

    >>> hash_parameters([32, 1, 31, 6])
    HashInfo(t=3, slots=(1, 5, 7), r=(None, 0, 1), offset=0, to_int=None)

    """

    # TODO: Support `to_int`
    # TODO: Store *original* values along side internal integers.

    # Create a set of all items to be hashed.
    items = frozenset(keys)

    if minimize:
        offset = 0 - min(items)
        print "Minimize by %d" % offset
        items = frozenset(x + offset for x in items)
    else:
        offset = 0

    # 1. Start with a square array (not stored) that is t units on a side.
    # Choose a t such that t*t >= max(S)
    t = int(math.ceil(math.sqrt(max(items))))
    assert t*t >= max(items)

    # 2. Place each key K in the square at location (x,y), where
    # x = K/t, y = K mod t.
    row_queue = place_items_in_square(items, t)

    print_square(row_queue, t)

    # 3. Arrange rows so that they'll fit into one row and generate a displacement vector.
    final_row, displacement_vector = arrange_rows(row_queue, t)

    # Return the parameters
    return HashInfo(
        t=t,
        slots=final_row,
        r=displacement_vector,
        offset=offset,
        # TODO: Provide this!
        to_int=None
    )

def place_items_in_square(items, t):
    """
    Returns a list of rows that are stored as a proiority queue to be used
    with heapq functions. 

    >>> place_items_in_square([1,5,7], 4)
    [(2, 1, [(0, 1), (1, 5)]), (3, 3, [(1, 7)])]
    >>> place_items_in_square([1,5,7], 3)
    [(1, 1, [(0, 1), (2, 7)]), (2, 2, [(1, 5)])]
    """

    # A minheap (because that's all that heapq supports :/)
    # of the length of each row. Why this is important is because
    # we'll be popping the largest rows when figuring out row displacements.
    # Each item is a tuple of (t - |row|, y, [(xpos_1, item_1), ...]).
    # Until the call to heapq.heapify(), the rows are ordered in
    # increasing row number (y).
    rows = [(t, y, []) for y in xrange(t)]

    for item in items:
        # Calculate the cell the item should fall in.
        x = item / t
        y = item % t

        # Push the item to its corresponding row...
        inverse_length, _, row_contents = rows[y]
        heapq.heappush(row_contents, (x, item))

        # Ensure the heap key is kept intact.
        rows[y] = inverse_length - 1, y, row_contents

    assert all(inv_len == t - len(rows) for inv_len, _, rows in rows)

    heapq.heapify(rows)

    # Return only rows that are populated.
    return [row for row in rows if row[2]]

def arrange_rows(row_queue, t):
    """
    Takes a priority queue as generated by place_items_in_square().
    Arranges the items from its conceputal square to one list. 
    Returns both the resultant vector, plus the displacement vector, to be
    used in the final output hash function.

    >>> rows = [(2, 1, [(0, 1), (1, 5)]), (3, 3, [(1, 7)])]
    >>> result, displacements = arrange_rows(rows, 4)
    >>> result
    (1, 5, 7, None)
    >>> displacements
    (None, 0, None, 1)

    >>> rows = [(1, 1, [(0, 1), (2, 7)]), (2, 2, [(1, 5)])]
    >>> result, displacements = arrange_rows(rows, 3)
    >>> result
    (1, 5, 7)
    >>> displacements
    (None, 0, 0)

        
    """

    # Create a set of all of the unoccupied columns.
    unoccupied_columns = collections.OrderedDict((x, True) for x in xrange(t))
    # Create the resultant and displacement vectors.
    result = [None] * t
    displacements = [None] * t

    while row_queue:
        # Get the next row to place.
        _inverse_length, y, row = heapq.heappop(row_queue)

        offset = find_first_fit(unoccupied_columns, row, t)
        # Calculate the offset of the first item.
        first_item_x = row[0][0]

        displacements[y] = offset
        for x, item in row:
            actual_x = x + offset
            result[actual_x] = item
            del unoccupied_columns[actual_x]
        
    return tuple(result), tuple(displacements)

        

def find_first_fit(unoccupied_columns, row, row_length):
    """
    Finds the first index that the row's items can fit.

    """
    for free_col in unoccupied_columns:
        # The offset is that such that the first item goes in the free column.
        first_item_x = row[0][0]
        offset = free_col - first_item_x
        if check_columns_fit(unoccupied_columns, row, offset, row_length):
            return offset

    raise ValueError("Row cannot possily fit in %r: %r"
            % (unoccupied_columns.keys(), row))

def check_columns_fit(unoccupied_columns, row, offset, row_length):
    """
    Checks if all the occupied columns in the row fit in the indices given by
    free columns.

    >>> check_columns_fit({0,1,2,3}, [(0, True), (2, True)], 0, 4)
    True
    >>> check_columns_fit({0,2,3}, [(2, True), (3, True)], 0, 4)
    True
    >>> check_columns_fit({}, [(2, True), (3, True)], 0, 4)
    False
    >>> check_columns_fit({0}, [(2, True)], 2, 4)
    True
    >>> check_columns_fit({0}, [(3, True)], 2, 4)
    False

    """
    for index, item in row:
        adjusted_index = (index + offset) % row_length

        # Check if the index is in the appropriate place.
        if adjusted_index not in unoccupied_columns:
            return False

    return True

def print_square(row_queue, t):
    occupied_rows = {y: row for _, y, row in row_queue}

    empty_row = ', '.join('...' for _ in xrange(t))

    for y in xrange(t):
        print '|',
        if y not in occupied_rows:
            print empty_row,
        else:
            row = dict(occupied_rows[y])
            all_cols = ('%3d' % row[x] if x in row else '...'
                    for x in xrange(t))
            print ', '.join(all_cols),

        print "|"



def print_array(array):
    for row in array:
        print '|',
        print '|'.join('%3d' % col
                if col is not None else '   ' for col in row),
        print '|'

def count_nones(seq):
    """Returns occurrences of None in the sequence"""
    i = 0
    for item in seq:
        if item is None:
            i += 1
    return i

def choose_non_none(array, column):
    for row in xrange(len(array)):
        item = array[row][column]
        if item is not None:
            return item
    raise ValueError("array at column %d does not contain any items: %r"
            % (column, array))


def rotate_nones(xs, n=0):
    """
    Rotates a list until the nth element is not None. Returns amount
    displaced.
    """
    assert n < len(xs), "Must choose n less than size of list."

    displacement = 0

    while xs[n] is None:
        head = xs.pop(0)
        xs.append(head)
        displacement += 1
        if displacement >= len(xs):
            raise ValueError("Row only contains None!")

    return displacement

def pair_elements(matrix):
    for number, row in enumerate(matrix):
        score = count_nones(row)
        if score != len(row):
            yield number, score, row

def make_queue(matrix):
    return sorted(pair_elements(matrix), key=itemgetter(1))

def get_first_non_none(xs):
    for i, x in enumerate(xs):
        if x is not None:
            return i
    raise ValueError("All values are None!")

def place_first_at(row, n):
    """
    Places the first item of the row at the nth column.

    >>> l = [None, None, None, 1]
    >>> place_first_at(l, 0)
    -3
    >>> l
    [1, None, None, None]
    >>> l = [1, None, 1, 2]
    >>> place_first_at(l, 2)
    2
    >>> l
    [1, 2, 1, None]
    """
    first = get_first_non_none(row)
    displacement = first - n

    #print "Displacement %d for row %r" % (displacement, row)

    if displacement != 0:
        rotate_row(row, displacement)
    # Rotate row actually takes negative displacement, so... yeah!
    return -displacement

def rotate_row(row, displacement):
    """
    Rotate the amount of times given the displacement. Positive displacements
    rotate to the left.

    >>> rotate_row([1, 2, 3, 4, 5], 1)
    [2, 3, 4, 5, 1]
    >>> rotate_row([1, 2, 3, 4, 5], -2)
    [4, 5, 1, 2, 3]
    """
    front = row[:displacement]
    back = row[displacement:]
    row[:] = back + front

    return row


def rearrange_rows(matrix):
    """
    Mutates the given matrix (list of lists) in order to make all items fit in
    each column. In addition to mutating the original array, returns a
    displacement vector -- a vector the size of the number of rows where each
    element specifies the amount that the corresponding row was displaced.

    The outer list must be a list of rows!
    """

    r = [0] * len(matrix)

    # List of unfilled columns, in ascending order.
    columns_unfilled = range(len(matrix[0]))

    # Sorted in descending order of most populous rows.
    row_queue = make_queue(matrix)

    print("Got these rows: ")
    pprint(row_queue)

    # Rotate all the rows appropriately.
    while row_queue:
        # Get the next elligible row.
        row_number, _score, limbo_row = row_queue.pop(0)

        #print "Next row is %d: %r (len %d)" % (row_number, limbo_row, _score)

        # Try placing it in every available next free slot.
        r[row_number] = try_all_free_slots(columns_unfilled, limbo_row)

        # Mark that columns have been filled. 
        occupied_columns = (index for index, item in enumerate(limbo_row)
                if item is not None)
        for col_num in occupied_columns:
            #print "Removing %d from %r" % (col_num, columns_unfilled)
            columns_unfilled.remove(col_num)

    return r
            

def try_all_free_slots(free_columns, row):
    for free_column in free_columns:
        if check_columns_okay(free_columns, row, free_column):
            # Found a free slot where all items can fit!
            #print "Row can move to column %d: %r" % (free_column, row)
            displacement = place_first_at(row, free_column)
            #print "Row is now", row
            return displacement
    raise ValueError("Could not fit row %r in free columns %r")

def check_columns_okay(free_columns, row, offset):
    """
    Checks if all the occupied columns in the row fit in the indices given by
    free columns.

    >>> check_columns_okay([0,1,2,3], [1, None, 3, None], 0)
    True
    >>> check_columns_okay([0,2,3], [None, None, 3, 4], 0)
    True
    >>> check_columns_okay([], [None, None, 3, 4], 0)
    False
    >>> check_columns_okay([0], [None, None, 3, None], 2)
    True
    >>> check_columns_okay([0], [None, None, None, 4], 2)
    False

    """
    for index, item in enumerate(row, start=offset):
        # Skip empty items in the row.
        if item is None:
            continue
        adjusted_index = index % len(row) 

        # Check if the index is in the appropriate place.
        if adjusted_index not in free_columns:
            #print "index %d not in %r" % (adjusted_index, free_columns)
            return False

    return True
        
        

def square_array(n):
    # TODO: No longer use an actual array!
    if type(n) is not int or n <= 0:
        raise ValueError("Must use non-negative integer.")

    return [[None] * n for _ in xrange(n)]

# This should be the output of the perfect hash mapping.
def perfect_hash(c):
    C = (  0,  1,  2,  3, 48, 17, 50, 19)
    r = (  0 , 0,  4,  0,  0,  0,  4,  0)
    k = ord(c) - 43
    x = k / 8
    y = k % 8
    i = r[x] + y
    return C[i]


if __name__ == '__main__':
    import doctest
    doctest.testmod(verbose=False)
    # TODO: Make this main more useful.
    """
    items = (ord(c) for c in '+-<>[],.')
    print hash_parameters(items, minimize=True)
    print [chr(perfect_hash(c) + 43) for c in '<>+-[],.']
    """


